package com.chrisw.vulnerabilityservice.service;

import com.chrisw.vulnerabilityservice.model.library.VulnerabilityType;
import com.chrisw.vulnerabilityservice.model.pom.Dependency;
import com.chrisw.vulnerabilityservice.model.pom.PomFile;
import com.chrisw.vulnerabilityservice.repo.LibraryRepo;
import com.chrisw.vulnerabilityservice.repo.VulnerabilityTypeRepo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.StringReader;
import java.net.URL;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
public class VulnerabilityService {


    private final VulnerabilityTypeRepo vulnerabilityTypeRepo;
    private final RestTemplate restTemplate;
    private final LibraryRepo libraryRepo;

    public VulnerabilityService(@Autowired VulnerabilityTypeRepo vulnerabilityTypeRepo, @Autowired LibraryRepo libraryRepo,
                                @Autowired RestTemplate restTemplate) {
        this.vulnerabilityTypeRepo = vulnerabilityTypeRepo;
        this.restTemplate = restTemplate;
        this.libraryRepo = libraryRepo;
    }

    public List<VulnerabilityType> findAllTypes() {
        return vulnerabilityTypeRepo.findAll();
    }


    //TODO below methods need unit tested
    //TODO refactor and clean below code
    //TODO use a factory below so we can pass different types of repos/dep management EG gradle
    //TODO include version in search
    public Set<Dependency> determineMavenVulnerabilitiesFromGitHub(URL githubUrl) {

        String pomString = getPomFromGitHub(githubUrl);
        try {
            PomFile pom = convertStringToPom(pomString);
//            //TODO check for versions with vulnerabilities using db
            return pom.getDependencies().stream().filter(x -> libraryRepo.existsByName(x.getArtifactId()))
                    .collect(Collectors.toSet());
        } catch (ParserConfigurationException | IOException | SAXException e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Failed to Process pom");
        }
    }

    private String getPomFromGitHub(URL url) {
        String[] splitUrl = url.getPath().split("/");
        String owner = splitUrl[splitUrl.length - 2];
        String repo = splitUrl[splitUrl.length - 1];
        String githubUrl = String.format("https://raw.githubusercontent.com/%s/%s/master/pom.xml", owner, repo);//TODO MOVE STRING TO CONFIG
        HttpHeaders headers = new HttpHeaders();
        headers.setAccept(Arrays.asList(MediaType.APPLICATION_XML));
        HttpEntity<String> entity = new HttpEntity<String>("parameters", headers);
        try {
            ResponseEntity<String> response = restTemplate.exchange(githubUrl, HttpMethod.GET, entity, String.class);
            return response.getBody();
        }catch(RestClientException e){
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR,"Failed to get pom file");
        }

    }

    //TODO jackson xml mapper overrides default json message converter
    //This causes rest calls to return xml
    //Work around is manually configuring message convert
    //Although this causes integ tests to behave weirdly
    private PomFile convertStringToPom(String pomString) throws IOException, SAXException, ParserConfigurationException {
        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();
        Document doc = docBuilder.parse(new InputSource(new StringReader(pomString)));
        doc.getDocumentElement().normalize();
        NodeList nList = doc.getElementsByTagName("dependency");
        Set<Dependency> deps = new HashSet<>();
        for (int i = 0; i < nList.getLength(); i++) {

            Node nNode = nList.item(i);
            if (nNode.getNodeType() == Node.ELEMENT_NODE) {
                Element eElement = (Element) nNode;
                String artifactId = eElement.getElementsByTagName("artifactId").item(0).getTextContent();
                NodeList optionalVersion = eElement.getElementsByTagName("version");
                String version;
                if(optionalVersion.getLength() == 0){
                    version = "No Version Specified";
                }else{
                    version = optionalVersion.item(0).getTextContent();
                }

                Dependency dep = new Dependency(artifactId, version);
                deps.add(dep);
            }
        }
        return new PomFile(deps);
    }
}
